Rust 30-Minute Coding Interview Practice Problems

1.  FizzBuzz
    - Print numbers 1-100, replace multiples of 3 with "Fizz", multiples of 5 with "Buzz", both with "FizzBuzz".

2.  Reverse a String
    - Input: &str, Output: String (reversed). Handle UTF-8 correctly.

3.  Find the Maximum Value in a Slice/Array
    - Input: &[i32], Output: Option<i32> (handle empty slice).

4.  Palindrome Check
    - Check if a string is a palindrome (ignore case/non-alphanumeric optional extension).

5.  Fibonacci Sequence
    - Return nth Fibonacci number (iterative or recursive with memoization).

6.  Two Sum
    - Given slice &[i32] and target i32, return indices of two numbers that add to target (Option<(usize, usize)>).

7.  Prime Number Check
    - Determine if a number is prime. Optimize (check up to sqrt(n)).

8.  Count Vowels in a String
    - Return count of vowels (a, e, i, o, u) in a given &str.

9.  Integer to Binary String
    - Convert i32 to a binary String representation (handle negative numbers optional).

10. Find the Most Frequent Element in a Slice
    - Input: &[i32], Output: Option<i32> (the mode). Handle ties.

11. Remove Duplicates from a Sorted Vector
    - In-place removal, return new length (like Leetcode problem).

12. Simple Linked List Implementation
    - Define Node struct with `next: Option<Box<Node>>` and implement push, pop.

13. Balanced Parentheses Check
    - Check if a string containing only (, ), {, }, [, ] is balanced.

14. Merge Two Sorted Vectors
    - Return a new sorted Vec<i32> containing all elements from two sorted input Vecs.

15. Basic HashMap Usage
    - Count frequency of words in a string, store in HashMap<&str, usize>.

16. Factorial Calculation
    - Compute n! (iterative and recursive). Handle overflow (use Option or u128).

17. Find the Missing Number
    - Given a slice of n-1 numbers from 1..n, find the missing number (use Gauss' formula).

18. Rotate Array by k Steps
    - In-place rotation of Vec<i32> by k positions (optimize with reverse method).

19. Binary Search
    - Implement iterative binary search on a sorted slice, return Option<usize> (index).

20. Flatten a Vector of Vectors
    - Given Vec<Vec<T>>, return a single Vec<T> containing all elements.

21. Find the Longest Common Prefix
    - Given a Vec<String>, return the longest common prefix String.

22. Valid Anagram Check
    - Determine if two strings are anagrams (use HashMap or sort).

23. First Unique Character in a String
    - Return index of first non-repeating character (Option<usize>).

24. Sum of Digits
    - Calculate sum of digits of an integer (e.g., 123 -> 6).

25. Implement a Simple Stack
    - Use Vec<T> to implement push, pop, peek, is_empty.

26. Find the Second Largest Element in a Slice
    - Return Option<i32> (handle slices with <2 elements).

27. Generate All Substrings of a String
    - Return Vec<&str> or Vec<String> containing all possible substrings.

28. Check if a Number is a Power of Two
    - Use bit manipulation (n & (n-1) == 0 for n > 0).

29. Reverse Words in a String
    - "hello world" -> "world hello". Handle multiple spaces optional.

30. Find the K-th Smallest Element
    - In an unsorted slice, find k-th smallest (sort or use selection algorithm).

31. Implement `is_sorted` Function
    - Check if a slice is sorted in ascending order (return bool).

32. Convert Roman Numeral to Integer
    - Given a valid Roman numeral string, return its integer value.

33. Implement a Basic Calculator
    - Evaluate a simple string like "3+5*2" (only +, -, *, /, no parentheses).

34. Find All Prime Numbers up to N (Sieve of Eratosthenes)
    - Return Vec<u32> of primes less than n.

35. Depth-First Search on a Graph
    - Represent graph as adjacency list (Vec<Vec<usize>>), implement DFS traversal.



    

Rust 30-Minute Coding Interview Practice List
=============================================

Ownership & Borrowing
---------------------
1. Reverse a String
   - Input: String
   - Output: reversed String
   - Be careful with UTF-8 (chars vs bytes)

2. First Non-Repeating Character
   - Use HashMap<char, usize>

3. Longest Word in a Sentence
   - Input: &str
   - Output: &str (not String)
   - Light lifetime practice

4. Remove Duplicates from a Vector
   - In-place using HashSet
   - Bonus: preserve order


Iterators & Functional Style
----------------------------
5. Sum of Even Numbers
   - Vec<i32> → i32
   - Use filter, map, sum

6. Word Frequency Counter
   - Input: &str
   - Output: HashMap<String, usize>

7. Flatten a Vector of Vectors
   - Vec<Vec<i32>> → Vec<i32>
   - Use flat_map

8. Check if All Elements Are Unique
   - Vec<i32> → bool
   - Early exit with HashSet


Algorithms (Classic Interview Problems)
---------------------------------------
9. Two Sum
   - Input: Vec<i32>, target
   - Output: indices

10. Binary Search
    - Manual implementation (no std helpers)

11. Palindrome Checker
    - Ignore non-alphanumeric
    - Case-insensitive

12. Merge Two Sorted Arrays
    - Bonus: without allocating a third vector


Structs, Enums & Pattern Matching
---------------------------------
13. Mini LRU Cache
    - Fixed capacity
    - HashMap + VecDeque

14. Expression Evaluator
    - Enum: Add | Sub | Mul | Div

15. State Machine
    - Enum-based states
    - Pattern match transitions


Error Handling
--------------
16. Safe Division Function
    - Return Result<f64, String>

17. Parse Integer from String
    - Wrap parse() errors manually

18. Read Numbers from stdin & Compute Average
    - Graceful error handling


Concurrency (Short Exercises)
-----------------------------
19. Parallel Sum
    - Split vector into chunks
    - Use std::thread

20. Producer / Consumer
    - mpsc::channel
    - One sender, one receiver


Interview Polish / Bonus
------------------------
21. Implement Debug manually for a struct
22. Implement Display for pretty printing
23. Implement From<&str> for a struct
24. Create a custom iterator for a struct
25. Write unit tests for any exercise above
